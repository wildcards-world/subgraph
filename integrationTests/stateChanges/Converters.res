// Generated by Codegen.res, PLEASE EDIT WITH CARE

open ConverterTypes

@decco.decode
type addTokenV3Data = {
  tokenId: bn,
  patronageNumerator: bn,
  tokenGenerationRate: bn,
}
@decco.decode
type remainingDepositUpdateData = {
  tokenPatron: address,
  newPrice: bn,
}
@decco.decode
type buyData = {
  tokenId: bn,
  owner: address,
  price: bn,
}

type stateChanges =
  | Unclassified(unclassifiedEvent)
  | AddTokenV3(addTokenV3Data)
  | RemainingDepositUpdate(remainingDepositUpdateData)
  | Buy(buyData)

let covertToStateChange = (eventName, paramsObject) => {
  // TODO: throw a (descriptive) error if the array of parameters are wrong somehow (or make a separate test?)
  switch eventName {
  | "AddTokenV3" => AddTokenV3(paramsObject->Js.Json.object_->addTokenV3Data_decode->Result.getExn)
  | "RemainingDepositUpdate" => RemainingDepositUpdate(paramsObject->Js.Json.object_->remainingDepositUpdateData_decode->Result.getExn)
  | "Buy" => Buy(paramsObject->Js.Json.object_->buyData_decode->Result.getExn)
  | name => Unclassified({name: name, data: paramsObject})
  }
}

type eventGroup = {
  allAddTokenV3Events: array<eventData<addTokenV3Data>>,
  allRemainingDepositUpdateEvents: array<eventData<remainingDepositUpdateData>>,
  allBuyEvents: array<eventData<buyData>>,
  allUnclassifiedEvents: array<ConverterTypes.unclassifiedEvent>,
}
let emptyEventGroups = {
  allAddTokenV3Events: [],
  allRemainingDepositUpdateEvents: [],
  allBuyEvents: [],
  allUnclassifiedEvents: [],
}

let addEventToCorrectGrouping = (
  currentEventGroups,
  {ConverterTypes.blockNumber: blockNumber, timestamp, txHash, data},
) => {
  switch data {
  | AddTokenV3(eventData) => {
      ...currentEventGroups,
      allAddTokenV3Events: currentEventGroups.allAddTokenV3Events->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | RemainingDepositUpdate(eventData) => {
      ...currentEventGroups,
      allRemainingDepositUpdateEvents: currentEventGroups.allRemainingDepositUpdateEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | Buy(eventData) => {
      ...currentEventGroups,
      allBuyEvents: currentEventGroups.allBuyEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | Unclassified(event) => {
      ...currentEventGroups,
      allUnclassifiedEvents: currentEventGroups.allUnclassifiedEvents->Array.concat([event]),
    }
  }
}

