// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Decco = require("decco/src/Decco.bs.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_json = require("rescript/lib/js/js_json.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var ConverterTypes = require("./ConverterTypes.bs.js");

function addTokenV3Data_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Decco.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Decco.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var tokenId = ConverterTypes.bn_decode(Belt_Option.getWithDefault(Js_dict.get(dict$1, "tokenId"), null));
  if (tokenId.TAG === /* Ok */0) {
    var patronageNumerator = ConverterTypes.bn_decode(Belt_Option.getWithDefault(Js_dict.get(dict$1, "patronageNumerator"), null));
    if (patronageNumerator.TAG === /* Ok */0) {
      var tokenGenerationRate = ConverterTypes.bn_decode(Belt_Option.getWithDefault(Js_dict.get(dict$1, "tokenGenerationRate"), null));
      if (tokenGenerationRate.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: {
                  tokenId: tokenId._0,
                  patronageNumerator: patronageNumerator._0,
                  tokenGenerationRate: tokenGenerationRate._0
                }
              };
      }
      var e = tokenGenerationRate._0;
      return {
              TAG: /* Error */1,
              _0: {
                path: ".tokenGenerationRate" + e.path,
                message: e.message,
                value: e.value
              }
            };
    }
    var e$1 = patronageNumerator._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".patronageNumerator" + e$1.path,
              message: e$1.message,
              value: e$1.value
            }
          };
  }
  var e$2 = tokenId._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".tokenId" + e$2.path,
            message: e$2.message,
            value: e$2.value
          }
        };
}

function remainingDepositUpdateData_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Decco.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Decco.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var tokenPatron = ConverterTypes.address_decode(Belt_Option.getWithDefault(Js_dict.get(dict$1, "tokenPatron"), null));
  if (tokenPatron.TAG === /* Ok */0) {
    var newPrice = ConverterTypes.bn_decode(Belt_Option.getWithDefault(Js_dict.get(dict$1, "newPrice"), null));
    if (newPrice.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                tokenPatron: tokenPatron._0,
                newPrice: newPrice._0
              }
            };
    }
    var e = newPrice._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".newPrice" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = tokenPatron._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".tokenPatron" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

function buyData_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Decco.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Decco.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var tokenId = ConverterTypes.bn_decode(Belt_Option.getWithDefault(Js_dict.get(dict$1, "tokenId"), null));
  if (tokenId.TAG === /* Ok */0) {
    var owner = ConverterTypes.address_decode(Belt_Option.getWithDefault(Js_dict.get(dict$1, "owner"), null));
    if (owner.TAG === /* Ok */0) {
      var price = ConverterTypes.bn_decode(Belt_Option.getWithDefault(Js_dict.get(dict$1, "price"), null));
      if (price.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: {
                  tokenId: tokenId._0,
                  owner: owner._0,
                  price: price._0
                }
              };
      }
      var e = price._0;
      return {
              TAG: /* Error */1,
              _0: {
                path: ".price" + e.path,
                message: e.message,
                value: e.value
              }
            };
    }
    var e$1 = owner._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".owner" + e$1.path,
              message: e$1.message,
              value: e$1.value
            }
          };
  }
  var e$2 = tokenId._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".tokenId" + e$2.path,
            message: e$2.message,
            value: e$2.value
          }
        };
}

function covertToStateChange(eventName, paramsObject) {
  switch (eventName) {
    case "AddTokenV3" :
        return {
                TAG: /* AddTokenV3 */1,
                _0: Belt_Result.getExn(addTokenV3Data_decode(paramsObject))
              };
    case "Buy" :
        return {
                TAG: /* Buy */3,
                _0: Belt_Result.getExn(buyData_decode(paramsObject))
              };
    case "RemainingDepositUpdate" :
        return {
                TAG: /* RemainingDepositUpdate */2,
                _0: Belt_Result.getExn(remainingDepositUpdateData_decode(paramsObject))
              };
    default:
      return {
              TAG: /* Unclassified */0,
              _0: {
                name: eventName,
                data: paramsObject
              }
            };
  }
}

var emptyEventGroups_allAddTokenV3Events = [];

var emptyEventGroups_allRemainingDepositUpdateEvents = [];

var emptyEventGroups_allBuyEvents = [];

var emptyEventGroups_allUnclassifiedEvents = [];

var emptyEventGroups = {
  allAddTokenV3Events: emptyEventGroups_allAddTokenV3Events,
  allRemainingDepositUpdateEvents: emptyEventGroups_allRemainingDepositUpdateEvents,
  allBuyEvents: emptyEventGroups_allBuyEvents,
  allUnclassifiedEvents: emptyEventGroups_allUnclassifiedEvents
};

function addEventToCorrectGrouping(currentEventGroups, param) {
  var data = param.data;
  var txHash = param.txHash;
  var timestamp = param.timestamp;
  var blockNumber = param.blockNumber;
  switch (data.TAG | 0) {
    case /* Unclassified */0 :
        return {
                allAddTokenV3Events: currentEventGroups.allAddTokenV3Events,
                allRemainingDepositUpdateEvents: currentEventGroups.allRemainingDepositUpdateEvents,
                allBuyEvents: currentEventGroups.allBuyEvents,
                allUnclassifiedEvents: Belt_Array.concat(currentEventGroups.allUnclassifiedEvents, [data._0])
              };
    case /* AddTokenV3 */1 :
        return {
                allAddTokenV3Events: Belt_Array.concat(currentEventGroups.allAddTokenV3Events, [{
                        blockNumber: blockNumber,
                        timestamp: timestamp,
                        txHash: txHash,
                        data: data._0
                      }]),
                allRemainingDepositUpdateEvents: currentEventGroups.allRemainingDepositUpdateEvents,
                allBuyEvents: currentEventGroups.allBuyEvents,
                allUnclassifiedEvents: currentEventGroups.allUnclassifiedEvents
              };
    case /* RemainingDepositUpdate */2 :
        return {
                allAddTokenV3Events: currentEventGroups.allAddTokenV3Events,
                allRemainingDepositUpdateEvents: Belt_Array.concat(currentEventGroups.allRemainingDepositUpdateEvents, [{
                        blockNumber: blockNumber,
                        timestamp: timestamp,
                        txHash: txHash,
                        data: data._0
                      }]),
                allBuyEvents: currentEventGroups.allBuyEvents,
                allUnclassifiedEvents: currentEventGroups.allUnclassifiedEvents
              };
    case /* Buy */3 :
        return {
                allAddTokenV3Events: currentEventGroups.allAddTokenV3Events,
                allRemainingDepositUpdateEvents: currentEventGroups.allRemainingDepositUpdateEvents,
                allBuyEvents: Belt_Array.concat(currentEventGroups.allBuyEvents, [{
                        blockNumber: blockNumber,
                        timestamp: timestamp,
                        txHash: txHash,
                        data: data._0
                      }]),
                allUnclassifiedEvents: currentEventGroups.allUnclassifiedEvents
              };
    
  }
}

exports.addTokenV3Data_decode = addTokenV3Data_decode;
exports.remainingDepositUpdateData_decode = remainingDepositUpdateData_decode;
exports.buyData_decode = buyData_decode;
exports.covertToStateChange = covertToStateChange;
exports.emptyEventGroups = emptyEventGroups;
exports.addEventToCorrectGrouping = addEventToCorrectGrouping;
/* ConverterTypes Not a pure module */
